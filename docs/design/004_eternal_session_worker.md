# 永続セッション・ワーカー (Eternal Session Worker) 構想

## 背景
GitHub Copilot などのプレミアムモデルにおいて、「1リクエスト = 1カウント」という制限がある。挨拶などの短いやり取りで回数を消費するのは非効率であり、1回のリクエスト（セッション）を長時間維持し、その中で大量のタスクを処理することでコストパフォーマンスを最大化する。

## コンセプト
「1時間のチケット」を購入するように、LLMとのチャットセッションを開始し、そのセッションが切れるまで、あるいはコンテキストウィンドウが埋まるまで、次々とタスクを流し込む。

## 動作フロー
1. **セッション開始**: プレミアムモデルとの対話セッションを確立する（CLIのインタラクティブモードや、SDKのChatSessionを利用）。
2. **待機ループ**: ローカルのタスクキュー（ディレクトリ）を監視する。
3. **タスク投入**: 新しいタスクを発見したら、**同一セッション内**で「次のタスクはこれだ：[タスク内容]」と送信する。
4. **成果物の受け取り**: LLMが出力したコードをパースし、ローカルの Worktree に適用、テストを実行する。
5. **フィードバック**: テスト結果（成功/失敗）をセッションに返し、必要なら修正（Self-repair）を同じセッションで行う。
6. **継続**: 次のタスクへ。セッションを閉じない限り、リクエスト数は「1」のまま維持される（理論上）。

## 課題
- **コンテキストの蓄積**: 多くのタスクをこなすと過去のコードがコンテキストを圧迫する。適宜「これまでのタスクの詳細は忘れていい。現在のディレクトリ構造とルールだけ保持せよ」といったプロンプトでの整理が必要。
- **タイムアウト**: 通信環境やプロバイダ側の制限によるセッション切断への対策。

## 期待される効果
- プレミアムモデルの利用効率を 10〜100倍 に向上させる。
- 「チケットを1枚消費して、1時間の重労働をアサインする」という業務モデルの確立。
