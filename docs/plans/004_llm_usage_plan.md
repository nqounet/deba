# Deba LLM利用計画書

## 0. 基本方針

| 方針 | 内容 |
|------|------|
| **コア原則** | 判断の質が下流工程に波及する箇所にプレミアムモデルを集中投入する |
| **最適化目標** | データ送信回数（API呼び出し回数）の最小化。処理の複雑さは許容する |
| **プレミアムモデル** | 最上位モデル（表向きには明示しない）。1回の呼び出しで複数の成果物をバンドル出力する |
| **軽量モデル** | 並列CLIツールで使用。定型的なコード生成・修正に限定 |
| **判断基準** | 試行時間が長くなっても手戻りを防ぐ方が総コストは低い |

---

## 1. LLM呼び出しポイント一覧

### 1.1 全呼び出しポイントのマップ

```
┌──────────────────────────────────────────────────────────────┐
│                    Deba LLM呼び出しマップ                      │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  [低頻度]                                                     │
│  ┌─────────────┐  ┌──────────────────┐                       │
│  │ Ingestion   │  │ Consolidation    │                       │
│  │ ★Premium    │  │ ★Premium         │                       │
│  │ 登録時1回   │  │ 週次 or 10ep毎   │                       │
│  └─────────────┘  └──────────────────┘                       │
│                                                              │
│  [タスク実行ごと]                                              │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ Phase A: 上流判断（★Premium × 1回）                     │  │
│  │ ┌──────────┐  ┌──────────┐  ┌──────────────────────┐  │  │
│  │ │ 要件定義  │→│ 実装計画  │→│ 実装時注意事項・判断  │  │  │
│  │ │ (Scribe) │  │(Planner) │  │ (コンテキスト注入)   │  │  │
│  │ └──────────┘  └──────────┘  └──────────────────────┘  │  │
│  │          ※1回のプロンプトで一括生成                      │  │
│  └────────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ Phase B: 実装（軽量モデル × N回・並列可）               │  │
│  │ ┌────────┐ ┌────────┐ ┌────────┐                      │  │
│  │ │ CLI #1 │ │ CLI #2 │ │ CLI #3 │  ...                 │  │
│  │ │コード生成│ │コード生成│ │テスト生成│                     │  │
│  │ └───┬────┘ └───┬────┘ └───┬────┘                      │  │
│  │     └──────────┼──────────┘                            │  │
│  │          テストランナー・リンター（LLM不要）              │  │
│  │                ↓ 失敗時のみ                              │  │
│  │          修正ループ（軽量モデル）                         │  │
│  └────────────────────────────────────────────────────────┘  │
│                        ↓                                     │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ Phase C: 振り返り（条件分岐）                           │  │
│  │                                                        │  │
│  │ [ユーザー修正あり] → ★Premium × 1回                    │  │
│  │   Reflection + 学び抽出 + エピソード記録                │  │
│  │                                                        │  │
│  │ [ユーザー修正なし] → LLM呼び出しなし                    │  │
│  │   定型エピソード記録のみ（テンプレート埋め込み）         │  │
│  └────────────────────────────────────────────────────────┘  │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 1.2 呼び出しポイント詳細

| # | 呼び出しポイント | モデル | 頻度 | 入力データ | 出力データ | 統合先 |
|---|-----------------|--------|------|-----------|-----------|--------|
| 1 | **Ingestion** | Premium | プロジェクト登録時1回 | ソースコード全体 or 要約 | プロジェクト構造・技術・役割の要約JSON | `brain/projects/` |
| 2 | **Phase A: 上流判断** | Premium | タスクごとに1回 | ユーザー要望 + プロジェクト知識 + 意味記憶 + 関連コード | 要件定義書 + 実装計画 + 注意事項（YAML構造化） | worktree `.deba/inbox/` |
| 3 | **Phase B: 実装** | 軽量 | タスクごとにN回（並列） | 実装計画の個別ステップ + 該当ファイル | コード変更 | worktree ソースコード |
| 4 | **Phase B: 修正** | 軽量 | テスト失敗時のみ | エラーメッセージ + 該当コード | 修正コード | worktree ソースコード |
| 5 | **Phase C: Reflection** | Premium | 修正ありタスクのみ | エピソード全体 + ユーザー修正内容 + 既存スキル | 自己評価 + 学び候補 + 成長ログエントリ | `brain/growth_log/`, `brain/episodes/` |
| 6 | **Consolidation** | Premium | 週次 or 10エピソード蓄積時 | 未分析エピソード群 + 既存スキル | 新規パターン + 学び候補 | `brain/growth_log/` |

---

## 2. プレミアムモデル使用回数の見積もり

### 2.1 タスクあたりのプレミアムモデル使用回数

| シナリオ | Phase A | Phase C | 合計 |
|---------|---------|---------|------|
| ユーザー修正なし（成功タスク） | 1回 | 0回 | **1回** |
| ユーザー修正あり（学習タスク） | 1回 | 1回 | **2回** |

### 2.2 月間見積もり（例: 1日5タスク、修正率30%の場合）

```
月間タスク数: 5 × 20営業日 = 100タスク
修正なしタスク: 70 × 1回 = 70回
修正ありタスク: 30 × 2回 = 60回
Consolidation: 100 / 10 = 10回
Ingestion: 想定2プロジェクト = 2回

月間プレミアムモデル合計: 約142回
月間軽量モデル: タスクあたり平均3回 × 100 = 約300回
```

### 2.3 成長に伴う使用量推移

信頼レベルが上がり修正率が下がるにつれ、Phase Cの発動頻度が自然に減少する:

| 信頼レベル | 想定修正率 | タスクあたりPremium平均 |
|-----------|-----------|----------------------|
| Lv1 見習い | ~50% | 1.5回 |
| Lv2 一人前 | ~20% | 1.2回 |
| Lv3 信頼 | ~10% | 1.1回 |

---

## 3. Phase A プロンプト設計指針

### 3.1 バンドル出力戦略

1回のプロンプトで以下の3成果物を同時に生成する。出力はYAML形式で構造化し、モデルの注意力を維持する。

```yaml
# Phase A 出力フォーマット（期待する構造）

requirements:
  goal: "（目的の1文要約）"
  specs:
    - item: "（仕様項目1）"
      reasoning: "（なぜこの仕様か）"
    - item: "（仕様項目2）"
      reasoning: "（理由）"
  acceptance_criteria:
    - "（完了条件1）"
    - "（完了条件2）"

implementation_plan:
  steps:
    - id: 1
      description: "（ステップ内容）"
      target_files: ["path/to/file.ts"]
      parallelizable: true
      dependencies: []
    - id: 2
      description: "（ステップ内容）"
      target_files: ["path/to/other.ts"]
      parallelizable: true
      dependencies: []
    - id: 3
      description: "（統合テスト）"
      parallelizable: false
      dependencies: [1, 2]

cautions:
  - context: "（関連する意味記憶や過去の学び）"
    instruction: "（この実装で注意すべき具体的な点）"
```

### 3.2 コンテキスト注入の優先順位

Phase Aのプロンプトに含めるコンテキストの優先順位（トークン上限に対する配分）:

| 優先度 | コンテキスト | トークン配分目安 | 理由 |
|--------|-------------|-----------------|------|
| 1（必須） | ユーザーの要望 | 5% | 起点。正確に伝達 |
| 2（必須） | 意味記憶（承認済みスキル） | 10% | 過去の学びを反映 |
| 3（必須） | 対象ファイルのソースコード | 40% | 実装判断の根拠 |
| 4（重要） | プロジェクト構造要約（Ingestion結果） | 15% | 全体の文脈理解 |
| 5（推奨） | 関連エピソード（直近の類似タスク） | 10% | 同種の失敗の回避 |
| 6（任意） | 依存先のインターフェース定義 | 20% | 整合性の確保 |

### 3.3 フォールバック条件

以下の場合、Phase Aを「要件定義」と「実装計画」の2回に分割する:

- 出力の `implementation_plan` セクションが不完全（ステップ数0、target_filesが空）
- ユーザーの要望が複数の独立した変更を含む（スコープが広い）
- 対象ファイルが10以上にまたがる大規模タスク

分割時のプレミアムモデル使用回数: 2回（Phase A1 + Phase A2）、最大3回（+ Phase C）

---

## 4. Phase B 並列実行設計

### 4.1 CLIツール分配ルール

Phase Aの `implementation_plan.steps` を解析し、`parallelizable: true` かつ `dependencies` が解決済みのステップを並列にCLIツールへ分配する。

```
Phase A出力 → パーサー → 依存グラフ構築 → 並列度決定
                                              ↓
                              ┌───────────────────────┐
                              │ 並列バッチ1            │
                              │ step1 → CLI#1 (軽量)  │
                              │ step2 → CLI#2 (軽量)  │
                              └───────────┬───────────┘
                                          ↓ 全完了待ち
                              ┌───────────────────────┐
                              │ 並列バッチ2            │
                              │ step3 → CLI#3 (軽量)  │
                              │  (step1,2に依存)       │
                              └───────────┬───────────┘
                                          ↓
                              テストランナー実行（LLM不要）
                                          ↓
                              失敗時のみ → 修正ループ（軽量）
```

### 4.2 軽量モデルへのプロンプト設計

軽量モデルには**判断を求めない**。Phase Aが生成した実装計画をそのまま実行する「指示遂行型」のプロンプトとする。

```markdown
# 指示
以下の実装ステップを正確に実行してください。設計判断は不要です。

## 実装ステップ
{{STEP_DESCRIPTION}}

## 対象ファイル
{{TARGET_FILE_CONTENT}}

## 注意事項
{{CAUTIONS_FROM_PHASE_A}}

## 出力
変更後のコードのみを出力してください。
```

---

## 5. Phase C 条件分岐設計

### 5.1 判定ロジック

```
タスク完了
  ↓
ユーザーの反応を判定
  ├─ [承認（修正なし）]
  │    → エピソード記録（テンプレート埋め込み、LLM不要）
  │    → 成功フラグ = true
  │    → 信頼スコア更新
  │    → 終了
  │
  └─ [修正あり]
       → エピソード記録（修正内容を含む）
       → ★Premium呼び出し: Reflection + 学び抽出
       → 成長ログに学び候補追加
       → ユーザーに承認UIを表示
       → 信頼スコア更新
       → 終了
```

### 5.2 Phase C バンドル出力

修正ありの場合、1回の呼び出しで以下を同時生成:

```yaml
# Phase C 出力フォーマット

reflection:
  what_happened: "（何が起きたか）"
  why_corrected: "（なぜユーザーが修正したか）"
  self_assessment: "（自己評価）"

learnings:
  - summary: "（学びの1文要約）"
    generalizability: "high | medium | project_specific"
    related_skills: "new | reinforce | modify:skill_name"
    proposed_rule: "（意味記憶に昇格する場合のルール文）"

episode_metadata:
  task_type: "（タスク種別）"
  complexity: 1-3
  success: false
  correction_severity: "minor | major | rejection"
```

---

## 6. 低頻度処理

### 6.1 Ingestion

| 項目 | 内容 |
|------|------|
| トリガー | プロジェクト新規登録時、またはユーザーが明示的に再実行 |
| モデル | Premium |
| 入力 | ソースコード全体（小〜中規模）or ファイルツリー + 主要ファイル抜粋（大規模） |
| 出力 | プロジェクト構造JSON（`brain/projects/{hash}.json`） |
| 最適化 | 差分Ingestion — 前回からの `git diff` のみを送信して既存JSONを更新 |

### 6.2 Consolidation

| 項目 | 内容 |
|------|------|
| トリガー | 同一プロジェクトで10エピソード蓄積 or 週次 |
| モデル | Premium |
| 入力 | 未分析エピソード群 + 既存意味記憶 |
| 出力 | 新規パターン候補 + 既存スキルの修正提案 |
| 最適化 | エピソードを要約してからバッチ送信（生データ全量は送らない） |

---

## 7. 呼び出し回数まとめ

### タスク1回あたり

| ケース | Premium | 軽量 | LLM不要の処理 |
|--------|---------|------|--------------|
| 修正なし | **1回** (Phase A) | N回 (Phase B) | エピソード記録、テスト実行 |
| 修正あり | **2回** (Phase A + C) | N回 (Phase B) | テスト実行 |
| 大規模タスク（フォールバック） | **2〜3回** (Phase A分割 + C) | N回 (Phase B) | テスト実行 |

### 定期処理

| 処理 | Premium | 頻度 |
|------|---------|------|
| Ingestion | 1回 | プロジェクト登録時（差分更新あり） |
| Consolidation | 1回 | 週次 or 10エピソードごと |

---

## 8. 今後の検証項目

- [ ] Phase A統合プロンプトのドラフト作成と、出力後半品質の検証テスト
- [ ] フォールバック判定の閾値チューニング（対象ファイル数、スコープの広さ）
- [ ] 軽量モデルの選定と、Phase Bにおけるコード生成品質の評価
- [ ] 「修正なし＝学びなし」仮定の妥当性を、運用データで継続検証
- [ ] 差分Ingestionの実装可否と精度検証
