# Deba アジャイル開発計画

## 0. 方針

### 0.1 開発原則

| 原則 | 内容 |
|------|------|
| **CLI First** | GUIは後回し。CLIインタラクティブモードで動作確認できたら次へ進む |
| **入出力の透明性** | 全フェーズで「何を入力し、何が出力されたか」をファイルに保存し、対比可能にする |
| **1スプリント = 1検証可能な成果物** | 各スプリントの完了時に「動かして確認できるもの」がある |
| **手戻り最小化** | 上流（Phase A）から検証し、上流が安定してから下流に進む |
| **設計ドキュメントとの対応** | 既存の設計書（001〜005）を参照しつつ、実装は必要最小限から始める |

### 0.2 検証の仕組み: 入出力スナップショット

全てのLLM呼び出しで、以下のセットを自動保存する。これにより「何が起きたか」を事後に対比・再現できる。

```
snapshots/
└── {task_id}/
    ├── input.md          # LLMに送ったプロンプト全文
    ├── output_raw.txt    # LLMから返ってきた生テキスト
    ├── output_parsed.yml # パース後の構造化データ（成功時）
    └── meta.json         # タイムスタンプ、モデル名、トークン数、所要時間
```

このスナップショットが「再現可能なテストケース」の役割を果たし、以下を可能にする：

- プロンプト改善時のビフォー/アフター比較
- パース失敗の原因分析
- モデル変更時の品質比較

---

## 1. スプリント構成

既存の設計書で定義されたフェーズ（Phase A → B → C）の上流から順に検証する。

```
Sprint 0: プロジェクトセットアップ
    ↓
Sprint 1: Phase A（上流判断）の検証  ← 最重要。ここが安定しないと全て手戻り
    ↓
Sprint 2: Phase A 出力のバリデーション自動化
    ↓
Sprint 3: Phase B（実装）の検証
    ↓
Sprint 4: Phase A → B の結合
    ↓
Sprint 5: Phase C（振り返り）とエピソード記録
    ↓
Sprint 6: 成長サイクルの統合
```

---

## 2. 各スプリントの詳細

### Sprint 0: プロジェクトセットアップ

**ゴール**: CLIから対話的にLLMを呼び出せる最小構成を作る

**成果物**:
- CLIスクリプト: 標準入力からテキストを受け取り、LLM APIに送信し、結果を表示する
- スナップショット保存: 入出力をファイルに保存する仕組み

**検証方法**:
```
$ deba chat "こんにちは"
→ LLMの応答が表示される
→ snapshots/ に入出力が保存されている
```

**決定事項（Sprint 0 で確定する）**:
- [ ] 実装言語の選択
- [ ] 使用するLLM API（モデルはまだ仮でよい）
- [ ] プロジェクト構造

**見積もり**: 小

---

### Sprint 1: Phase A の検証

**ゴール**: ユーザーの要望を入力すると、構造化された要件定義・実装計画・注意事項がYAMLで返ってくることを確認する

**前提**: `docs/drafts/phase_a_prompt_draft.md` のプロンプトテンプレートを使用

**成果物**:
- CLIコマンド: `deba plan "ヘッダーコンポーネントを分割して"`
- Phase Aプロンプトテンプレートの組み込み
- スナップショットによる入出力の対比

**検証方法**:
```
$ deba plan "ユーザー登録フォームにバリデーションを追加して"

# 入力（自動保存される）:
#   - ユーザーの要望テキスト
#   - 使用したプロンプトテンプレート
#   - 注入したコンテキスト（あれば）

# 出力（自動保存される）:
#   - YAML形式の要件定義 + 実装計画 + 注意事項

# 確認ポイント:
#   1. YAMLがパースできるか
#   2. 必須フィールド（goal, steps, acceptance_criteria）が存在するか
#   3. stepsの内容が要望に対して妥当か（人手で確認）
```

**この時点で同時に検証できること**:
- `docs/drafts/yaml_vs_json_test_plan.md` の一部（YAML出力の安定性）
- `docs/drafts/phase_a_prompt_draft.md` の出力後半品質

**見積もり**: 中（プロンプト調整の反復あり）

---

### Sprint 2: Phase A バリデーション自動化

**ゴール**: Phase Aの出力を自動的にバリデーションし、品質を担保する

**成果物**:
- YAMLパーサー + スキーマ検証（005 §5.2）
- 依存グラフ整合性チェック
- バリデーション結果のレポート出力

**検証方法**:
```
$ deba plan "..." | deba validate

# 出力例:
# ✓ YAML parse: OK
# ✓ Schema: OK (goal, steps[3], acceptance_criteria[2])
# ✓ Dependency graph: OK (no cycles, 2 batches)
# ⚠ Cautions: empty (warning only)
```

**見積もり**: 小

---

### Sprint 3: Phase B の検証

**ゴール**: Phase Aの出力（1ステップ分）を入力として、軽量モデルがコード変更を生成できることを確認する

**前提**: Phase Aの出力が安定していること（Sprint 1-2 完了）

**成果物**:
- CLIコマンド: `deba execute --step 1 --plan snapshots/{task_id}/output_parsed.yml`
- 軽量モデルへの「指示遂行型」プロンプト（005 §6.3）の組み込み
- ステップ単位の入出力スナップショット

**検証方法**:
```
$ deba execute --step 1 --plan snapshots/task_001/output_parsed.yml

# 入力（自動保存）:
#   - Phase Aの該当ステップ
#   - 対象ファイルのソースコード
#   - 注意事項

# 出力（自動保存）:
#   - 変更後のコード（または diff）

# 確認ポイント:
#   1. 生成コードが指示通りか（入出力を対比）
#   2. 余計な変更がないか
#   3. テスト/リンターが通るか（該当する場合）
```

**この時点で同時に検証できること**:
- `docs/drafts/lightweight_model_evaluation_plan.md` の評価テスト

**見積もり**: 中

---

### Sprint 4: Phase A → B 結合

**ゴール**: ユーザーの要望から、計画→実装→テスト実行まで一気通貫で動くことを確認する

**成果物**:
- CLIコマンド: `deba run "要望テキスト"`（plan → validate → execute の一連を実行）
- 並列バッチ実行（005 §6.1-6.2）の基本実装
- テスト/リンター実行の統合

**検証方法**:
```
$ deba run "ユーザー登録フォームにメールアドレスのバリデーションを追加して"

# 実行ログ:
# [Phase A] Planning... done (3 steps)
# [Validate] Schema OK, 2 parallel batches
# [Phase B] Batch 1: step 1, step 2 (parallel)... done
# [Phase B] Batch 2: step 3 (depends on 1,2)... done
# [Test] Running tests... 3/3 passed ✓
#
# 入出力スナップショット:
#   snapshots/task_002/
#   ├── phase_a_input.md
#   ├── phase_a_output.yml
#   ├── step_1_input.md
#   ├── step_1_output.txt
#   ├── step_2_input.md
#   ├── step_2_output.txt
#   ├── step_3_input.md
#   ├── step_3_output.txt
#   └── test_result.txt
```

**見積もり**: 大

---

### Sprint 5: Phase C とエピソード記録

**ゴール**: タスク完了後のユーザーフィードバック → 振り返り → エピソード記録を動かす

**成果物**:
- CLIでのフィードバック入力: `deba review {task_id}`
- 修正ありの場合に Reflection 実行（005 §7）
- エピソード記録の自動保存（003 §1.1）

**検証方法**:
```
$ deba review task_002
> 承認しますか？ [y/n/修正内容を入力]: n
> 修正内容: step 2でバリデーションのエラーメッセージが英語だった。日本語にすべき。

# 出力:
# [Phase C] Reflection実行中...
# 学び候補: 「エラーメッセージは日本語で出力する」
# 汎用性: project_specific
# → エピソード保存: brain/episodes/2026-02-23_001.md
# → 成長ログ追加: brain/growth_log/2026-02.md
```

**見積もり**: 中

---

### Sprint 6: 成長サイクル統合

**ゴール**: 意味記憶がPhase Aのコンテキストに反映され、過去の学びが活用されていることを確認する

**成果物**:
- 意味記憶（スキル）のPhase Aプロンプトへの注入
- `deba skills` コマンドで獲得スキル一覧を表示
- 「前回の学びを活用しました」のインジケーター

**検証方法**:
```
# 前回「エラーメッセージは日本語で出力する」を学習済み
$ deba run "パスワードリセットフォームにバリデーションを追加して"

# Phase A出力のcautionsに:
#   - context: "エラーメッセージは日本語で出力する (2026-02-23 学習)"
#     instruction: "バリデーションエラーメッセージは日本語で記述すること"
# が含まれていることを確認
```

**見積もり**: 中

---

## 3. スプリント間の依存関係

```
Sprint 0 ─→ Sprint 1 ─→ Sprint 2 ─→ Sprint 4 ─→ Sprint 5 ─→ Sprint 6
                                  ↗
             Sprint 3 ────────────
```

- Sprint 1（Phase A）と Sprint 3（Phase B）は並行して進められるが、Phase Aの安定が優先
- Sprint 4 は Sprint 2 と Sprint 3 の両方が完了してから着手

---

## 4. 技術的な判断ポイント（Sprint 0 で決定）

Sprint 0 の段階で以下を決め、先に進む。完璧を求めず、動くものを作ることを優先する。

| 判断項目 | 選択肢 | 判断基準 |
|---------|--------|---------|
| 実装言語 | Sprint 0 で議論 | CLIの書きやすさ、YAMLパーサーの充実度、LLM SDK の有無 |
| LLM API | Sprint 0 で議論 | CLI対話で動作確認可能なもの。まずは1つに絞る |
| LLMモデル（Premium） | Sprint 1 で仮決定 | Phase Aの出力品質で判断。後から変更可能 |
| LLMモデル（軽量） | Sprint 3 で仮決定 | Phase Bのコード生成品質で判断 |
| YAML vs JSON | Sprint 1-2 の実測で確定 | パース成功率90%以上ならYAML採用 |

---

## 5. 「入出力の対比」による品質保証

全スプリントを通じて、以下のサイクルでプロンプトと出力の品質を改善する：

```
1. CLIでタスクを実行する
2. スナップショット（入出力ペア）が自動保存される
3. 出力を確認し、問題があれば：
   a. プロンプトを修正する
   b. 同じ入力で再実行する
   c. ビフォー/アフターをスナップショットで比較する
4. 良い入出力ペアは「ゴールデンテスト」として保存する
5. プロンプト変更時に、ゴールデンテストで回帰チェックする
```

これにより、プロンプト改善のたびに「前は動いていたのに壊れた」という手戻りを防ぐ。

---

## 6. 既存設計書との対応

| Sprint | 検証対象の設計書セクション |
|--------|------------------------|
| Sprint 0 | 001 §2（ディレクトリ構造の基礎部分のみ） |
| Sprint 1 | 005 §5.1（バンドル出力戦略）, docs/drafts/phase_a_prompt_draft.md |
| Sprint 2 | 005 §5.2（バリデーション）, 005 §5.5（YAML vs JSON） |
| Sprint 3 | 005 §6.3（軽量モデルプロンプト）, docs/drafts/lightweight_model_evaluation_plan.md |
| Sprint 4 | 005 §6.1-6.2（並列実行）, 005 §6.4（エスカレーション） |
| Sprint 5 | 005 §7（Phase C）, 003 §1.1（エピソード記憶）, 003 §2.2（Reflection） |
| Sprint 6 | 003 §1.3（意味記憶）, 005 §5.3（コンテキスト注入） |

---

## 7. やらないこと（スコープ外）

以下は本計画のスプリント範囲外とし、必要になった時点で計画に追加する：

- GUI（Electron等）の実装
- Git Worktree の自動管理（001の詳細フロー）
- Ingestion（プロジェクト構造の自動解析）
- Consolidation（定期統合）
- オフライン対応
- マスキング処理
- 信頼レベルの自動昇格
- コスト上限管理
